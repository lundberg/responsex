{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"RESPX  <p>Mock HTTPX with awesome request patterns and response side effects.</p> <p> </p>"},{"location":"#quickstart","title":"QuickStart","text":"<p>RESPX is a simple, yet powerful, utility for mocking out the HTTPX, and HTTP Core, libraries.</p> <p>Start by patching <code>HTTPX</code>, using <code>respx.mock</code>, then add request routes to mock responses.</p> <pre><code>import httpx\nimport respx\n\nfrom httpx import Response\n\n\n@respx.mock\ndef test_example():\n    my_route = respx.get(\"https://foo.bar/\").mock(return_value=Response(204))\n    response = httpx.get(\"https://foo.bar/\")\n    assert my_route.called\n    assert response.status_code == 204\n</code></pre> <p>Read the User Guide for a complete walk-through.</p>"},{"location":"#pytest-httpx","title":"pytest + httpx","text":"<p>For a neater <code>pytest</code> experience, RESPX includes a <code>respx_mock</code> fixture for easy <code>HTTPX</code> mocking, along with an optional <code>respx</code> marker to fine-tune the mock settings.</p> <pre><code>import httpx\nimport pytest\n\n\ndef test_default(respx_mock):\n    respx_mock.get(\"https://foo.bar/\").mock(return_value=httpx.Response(204))\n    response = httpx.get(\"https://foo.bar/\")\n    assert response.status_code == 204\n\n\n@pytest.mark.respx(base_url=\"https://foo.bar\")\ndef test_with_marker(respx_mock):\n    respx_mock.get(\"/baz/\").mock(return_value=httpx.Response(204))\n    response = httpx.get(\"https://foo.bar/baz/\")\n    assert response.status_code == 204\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Install with pip:</p> <pre><code>$ pip install respx\n</code></pre> <p>Requires Python 3.8+ and HTTPX 0.25+. See Changelog for older HTTPX compatibility.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#router","title":"Router","text":""},{"location":"api/#configuration","title":"Configuration","text":"<p>Creates a mock <code>Router</code> instance, ready to be used as decorator/manager for activation.</p> <p><code>respx.mock(assert_all_mocked=True, assert_all_called=True, base_url=None)</code></p> <p>Parameters:</p> <ul> <li>assert_all_mocked - (optional) bool - default: <code>True</code>   Asserts that all sent and captured <code>HTTPX</code> requests are routed and mocked.   If disabled, all non-routed requests will be auto mocked with status code <code>200</code>.  </li> <li>assert_all_called - (optional) bool - default: <code>True</code>   Asserts that all added and mocked routes were called when exiting context.  </li> <li>base_url - (optional) str   Base URL to match, on top of each route specific pattern and/or side effect.</li> </ul> <p>Returns: <code>Router</code></p> <p>NOTE</p> <p>When using the default mock router <code>respx.mock</code>, without settings, <code>assert_all_called</code> is disabled.</p> <p>pytest</p> <p>Use the <code>@pytest.mark.respx(...)</code> marker with these parameters to configure the <code>respx_mock</code> pytest fixture.</p>"},{"location":"api/#route","title":".route()","text":"<p>Adds a new, optionally named, <code>Route</code> with given patterns and/or lookups combined, using the AND operator.</p> <p><code>respx.route(*patterns, name=None, **lookups)</code></p> <p>Parameters:</p> <ul> <li>patterns - (optional) args   One or more pattern objects.</li> <li>lookups - (optional) kwargs   One or more pattern keyword lookups, given as <code>&lt;pattern&gt;__&lt;lookup&gt;=value</code>.</li> <li>name - (optional) str   Name this route.</li> </ul> <p>Returns: <code>Route</code></p>"},{"location":"api/#get-post","title":".get(), .post(), ...","text":"<p>HTTP method helpers to add routes, mimicking the HTTPX Helper Functions.</p> <p><code>respx.get(url, name=None, **lookups)</code></p> <p><code>respx.options(...)</code></p> <p><code>respx.head(...)</code></p> <p><code>respx.post(...)</code></p> <p><code>respx.put(...)</code></p> <p><code>respx.patch(...)</code></p> <p><code>respx.delete(...)</code></p> <p>Parameters:</p> <ul> <li>url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL   Request URL to match, full or partial, turned into a URL pattern.</li> <li>name - (optional) str   Name this route.</li> <li>lookups - (optional) kwargs   One or more pattern keyword lookups, given as <code>&lt;pattern&gt;__&lt;lookup&gt;=value</code>.</li> </ul> <p>Returns: <code>Route</code></p> <pre><code>respx.get(\"https://example.org/\", params={\"foo\": \"bar\"}, ...)\n</code></pre>"},{"location":"api/#request","title":".request()","text":"<p><code>respx.request(method, url, name=None, **lookups)</code></p> <p>Parameters:</p> <ul> <li>method - str   Request HTTP method to match.</li> <li>url - (optional) str | compiled regex | tuple (httpcore) | httpx.URL   Request URL to match, full or partial, turned into a URL pattern.</li> <li>name - (optional) str   Name this route.</li> <li>lookups - (optional) kwargs   One or more pattern keyword lookups, given as <code>&lt;pattern&gt;__&lt;lookup&gt;=value</code>.</li> </ul> <p>Returns: <code>Route</code></p> <pre><code>respx.request(\"GET\", \"https://example.org/\", params={\"foo\": \"bar\"}, ...)\n</code></pre>"},{"location":"api/#route_1","title":"Route","text":""},{"location":"api/#mock","title":".mock()","text":"<p>Mock a route's response or side effect.</p> <p><code>route.mock(return_value=None, side_effect=None)</code></p> <p>Parameters:</p> <ul> <li>return_value - (optional) Response   HTTPX Response to mock and return.</li> <li>side_effect - (optional) Callable | Exception | Iterable of httpx.Response/Exception Side effect to call, exception to raise or stacked responses to respond with in order.</li> </ul> <p>Returns: <code>Route</code></p>"},{"location":"api/#return_value","title":".return_value","text":"<p>Setter for the <code>HTTPX</code> Response to return.</p> <p><code>route.return_value = Response(204)</code></p>"},{"location":"api/#side_effect","title":".side_effect","text":"<p>Setter for the side effect to trigger.</p> <p><code>route.side_effect = ...</code></p> <p>See route.mock() for valid side effect types.</p>"},{"location":"api/#respond","title":".respond()","text":"<p>Shortcut for creating and mocking a <code>HTTPX</code> Response.</p> <p><code>route.respond(status_code=200, headers=None, cookies=None, content=None, text=None, html=None, json=None, stream=None, content_type=None)</code></p> <p>Parameters:</p> <ul> <li>status_code - (optional) int - default: <code>200</code>   Response status code to mock.</li> <li>headers - (optional) dict | Sequence[tuple[str, str]]   Response headers to mock.</li> <li>cookies - (optional) dict | Sequence[tuple[str, str]] | Sequence[SetCookie]   Response cookies to mock as <code>Set-Cookie</code> headers. See SetCookie.</li> <li>content - (optional) bytes | str | Iterable[bytes]   Response raw content to mock.</li> <li>text - (optional) str   Response text content to mock, with automatic content-type header added.</li> <li>html - (optional) str   Response HTML content to mock, with automatic content-type header added.</li> <li>json - (optional) str | list | dict   Response JSON content to mock, with automatic content-type header added.</li> <li>stream - (optional) Iterable[bytes]   Response stream to mock.</li> <li>content_type - (optional) str   Response <code>Content-Type</code> header to mock.</li> </ul> <p>Returns: <code>Route</code></p>"},{"location":"api/#pass_through","title":".pass_through()","text":"<p><code>route.pass_through(value=True)</code></p> <p>Parameters:</p> <ul> <li>value - (optional) bool - default: <code>True</code>   Mark route to pass through, sending matched requests to real server, e.g. don't mock.</li> </ul> <p>Returns: <code>Route</code></p>"},{"location":"api/#response","title":"Response","text":"<p>NOTE</p> <p>This is a partial reference for how to the instantiate the HTTPX <code>Response</code>class, e.g. not a RESPX class.</p> <p><code>httpx.Response(status_code, headers=None, content=None, text=None, html=None, json=None, stream=None)</code></p> <p>Parameters:</p> <ul> <li>status_code - int   HTTP status code.</li> <li>headers - (optional) dict | httpx.Headers   HTTP headers.</li> <li>content - (optional) bytes | str | Iterable[bytes]   Raw content.</li> <li>text - (optional) str   Text content, with automatic content-type header added.</li> <li>html - (optional) str   HTML content, with automatic content-type header added.</li> <li>json - (optional) str | list | dict   JSON content, with automatic content-type header added.</li> <li>stream - (optional) Iterable[bytes]   Content stream.</li> </ul> <p>Cookies</p> <p>Use respx.SetCookie(...) to produce <code>Set-Cookie</code> headers.</p>"},{"location":"api/#setcookie","title":"SetCookie","text":"<p>A utility to render a <code>(\"Set-Cookie\", &lt;cookie header value&gt;)</code> tuple. See route respond shortcut for alternative use.</p> <p><code>respx.SetCookie(name, value, path=None, domain=None, expires=None, max_age=None, http_only=False, same_site=None, secure=False, partitioned=False)</code></p> <pre><code>import respx\nrespx.post(\"https://example.org/\").mock(\n    return_value=httpx.Response(200, headers=[SetCookie(\"foo\", \"bar\")])\n)\n</code></pre>"},{"location":"api/#patterns","title":"Patterns","text":""},{"location":"api/#m","title":"M()","text":"<p>Creates a reusable pattern, combining multiple arguments using the AND operator.</p> <p><code>M(*patterns, **lookups)</code></p> <p>Parameters:</p> <ul> <li>patterns - (optional) args   One or more pattern objects.</li> <li>lookups - (optional) kwargs   One or more pattern keyword lookups, given as <code>&lt;pattern&gt;__&lt;lookup&gt;=value</code>.</li> </ul> <p>Returns: <code>Pattern</code></p> <pre><code>import respx\nfrom respx.patterns import M\npattern = M(host=\"example.org\")\nrespx.route(pattern)\n</code></pre> <p>See operators for advanced usage.</p>"},{"location":"api/#method","title":"Method","text":"<p>Matches request HTTP method, using <code>eq</code> as default lookup.</p> <p>Key: <code>method</code> Lookups: eq, in</p> <pre><code>respx.route(method=\"GET\")\nrespx.route(method__in=[\"PUT\", \"PATCH\"])\n</code></pre>"},{"location":"api/#scheme","title":"Scheme","text":"<p>Matches request URL scheme, using <code>eq</code> as default lookup.</p> <p>Key: <code>scheme</code> Lookups: eq, in</p> <pre><code>respx.route(scheme=\"https\")\nrespx.route(scheme__in=[\"http\", \"https\"])\n</code></pre>"},{"location":"api/#host","title":"Host","text":"<p>Matches request URL host, using <code>eq</code> as default lookup.</p> <p>Key: <code>host</code> Lookups: eq, regex, in</p> <pre><code>respx.route(host=\"example.org\")\nrespx.route(host__regex=r\"example\\.(org|com)\")\nrespx.route(host__in=[\"example.org\", \"example.com\"])\n</code></pre>"},{"location":"api/#port","title":"Port","text":"<p>Matches request URL port, using <code>eq</code> as default lookup.</p> <p>Key: <code>port</code> Lookups: eq, in</p> <pre><code>respx.route(port=8000)\nrespx.route(port__in=[2375, 2376])\n</code></pre>"},{"location":"api/#path","title":"Path","text":"<p>Matches request URL path, using <code>eq</code> as default lookup.</p> <p>Key: <code>path</code> Lookups: eq, regex, startswith, in</p> <pre><code>respx.route(path=\"/api/foobar/\")\nrespx.route(path__regex=r\"^/api/(?P&lt;slug&gt;\\w+)/\")\nrespx.route(path__startswith=\"/api/\")\nrespx.route(path__in=[\"/api/v1/foo/\", \"/api/v2/foo/\"])\n</code></pre>"},{"location":"api/#params","title":"Params","text":"<p>Matches request URL query params, using <code>contains</code> as default lookup.</p> <p>Key: <code>params</code> Lookups: contains, eq</p> <pre><code>respx.route(params={\"foo\": \"bar\", \"ham\": \"spam\"})\nrespx.route(params=[(\"foo\", \"bar\"), (\"ham\", \"spam\")])\nrespx.route(params=((\"foo\", \"bar\"), (\"ham\", \"spam\")))\nrespx.route(params=\"foo=bar&amp;ham=spam\")\n</code></pre> <p>NOTE</p> <p>A request querystring with multiple parameters of the same name is treated as an ordered list when matching.</p> <p>ANY value</p> <p>Use <code>mock.ANY</code> as value to only match on parameter presence, e.g. <code>respx.route(params={\"foo\": ANY})</code>.</p>"},{"location":"api/#url","title":"URL","text":"<p>Matches request URL.</p> <p>When no lookup is given, <code>url</code> works as a shorthand pattern, combining individual request URL parts, using the AND operator.</p> <p>Key: <code>url</code> Lookups: eq, regex, startswith</p> <pre><code>respx.get(\"//example.org/foo/\")  # == M(host=\"example.org\", path=\"/foo/\")\nrespx.get(url__eq=\"https://example.org:8080/foobar/?ham=spam\")\nrespx.get(url__regex=r\"https://example.org/(?P&lt;slug&gt;\\w+)/\")\nrespx.get(url__startswith=\"https://example.org/api/\")\nrespx.get(\"all://*.example.org/foo/\")\n</code></pre>"},{"location":"api/#content","title":"Content","text":"<p>Matches request raw content, using eq as default lookup.</p> <p>Key: <code>content</code> Lookups: eq, contains</p> <pre><code>respx.post(\"https://example.org/\", content=\"foobar\")\nrespx.post(\"https://example.org/\", content=b\"foobar\")\nrespx.post(\"https://example.org/\", content__contains=\"bar\")\n</code></pre>"},{"location":"api/#data","title":"Data","text":"<p>Matches request form data, excluding files, using eq as default lookup.</p> <p>Key: <code>data</code> Lookups: eq, contains</p> <pre><code>respx.post(\"https://example.org/\", data={\"foo\": \"bar\"})\n</code></pre>"},{"location":"api/#files","title":"Files","text":"<p>Matches files within request form data, using contains as default lookup.</p> <p>Key: <code>files</code> Lookups: contains, eq</p> <pre><code>respx.post(\"https://example.org/\", files={\"some_file\": b\"...\"})\nrespx.post(\"https://example.org/\", files={\"some_file\": ANY})\nrespx.post(\"https://example.org/\", files={\"some_file\": (\"filename.txt\", b\"...\")})\nrespx.post(\"https://example.org/\", files={\"some_file\": (\"filename.txt\", ANY)})\n</code></pre>"},{"location":"api/#json","title":"JSON","text":"<p>Matches request json content, using eq as default lookup.</p> <p>Key: <code>json</code> Lookups: eq</p> <pre><code>respx.post(\"https://example.org/\", json={\"foo\": \"bar\"})\n</code></pre> <p>The <code>json</code> pattern also supports path traversing, i.e. <code>json__&lt;path&gt;=&lt;value&gt;</code>.</p> <pre><code>respx.post(\"https://example.org/\", json__foobar__0__ham=\"spam\")\nhttpx.post(\"https://example.org/\", json={\"foobar\": [{\"ham\": \"spam\"}]})\n</code></pre>"},{"location":"api/#headers","title":"Headers","text":"<p>Matches request headers, using contains as default lookup.</p> <p>Key: <code>headers</code> Lookups: contains, eq</p> <pre><code>respx.route(headers={\"foo\": \"bar\", \"ham\": \"spam\"})\nrespx.route(headers=[(\"foo\", \"bar\"), (\"ham\", \"spam\")])\n</code></pre>"},{"location":"api/#cookies","title":"Cookies","text":"<p>Matches request cookie header, using contains as default lookup.</p> <p>Key: <code>cookies</code> Lookups: contains, eq</p> <pre><code>respx.route(cookies={\"foo\": \"bar\", \"ham\": \"spam\"})\nrespx.route(cookies=[(\"foo\", \"bar\"), (\"ham\", \"spam\")])\n</code></pre>"},{"location":"api/#lookups","title":"Lookups","text":""},{"location":"api/#eq","title":"eq","text":"<pre><code>M(path=\"/foo/bar/\")\nM(path__eq=\"/foo/bar/\")\n</code></pre>"},{"location":"api/#contains","title":"contains","text":"<p>Case-sensitive containment test.</p> <pre><code>M(params__contains={\"id\": \"123\"})\n</code></pre>"},{"location":"api/#in","title":"in","text":"<p>Case-sensitive within test.</p> <pre><code>M(method__in=[\"PUT\", \"PATCH\"])\n</code></pre>"},{"location":"api/#regex","title":"regex","text":"<pre><code>M(path__regex=r\"^/api/(?P&lt;slug&gt;\\w+)/\")\n</code></pre>"},{"location":"api/#startswith","title":"startswith","text":"<p>Case-sensitive starts-with.</p> <pre><code>M(path__startswith=\"/api/\")\n</code></pre>"},{"location":"api/#operators","title":"Operators","text":"<p>Patterns can be combined using bitwise operators, creating new patterns.</p>"},{"location":"api/#and","title":"AND (&amp;)","text":"<p>Combines two <code>Pattern</code>s using <code>and</code> operator.</p> <pre><code>M(scheme=\"http\") &amp; M(host=\"example.org\")\n</code></pre>"},{"location":"api/#or","title":"OR (&amp;)","text":"<p>Combines two <code>Pattern</code>s using <code>or</code> operator.</p> <pre><code>M(method=\"PUT\") | M(method=\"PATCH\")\n</code></pre>"},{"location":"api/#invert","title":"INVERT (~)","text":"<p>Inverts a <code>Pattern</code> match.</p> <pre><code>~M(params={\"foo\": \"bar\"})\n</code></pre>"},{"location":"examples/","title":"Test Case Examples","text":"<p>Here's some test case examples, not exactly how-to, but to be inspired from.</p>"},{"location":"examples/#pytest","title":"pytest","text":""},{"location":"examples/#built-in-fixture","title":"Built-in Fixture","text":"<p>RESPX includes the <code>respx_mock</code> pytest httpx fixture.</p> <pre><code>import httpx\n\n\ndef test_fixture(respx_mock):\n    respx_mock.get(\"https://foo.bar/\").mock(return_value=httpx.Response(204))\n    response = httpx.get(\"https://foo.bar/\")\n    assert response.status_code == 204\n</code></pre>"},{"location":"examples/#built-in-marker","title":"Built-in Marker","text":"<p>To configure the <code>respx_mock</code> fixture, use the <code>respx</code> marker.</p> <pre><code>import httpx\nimport pytest\n\n\n@pytest.mark.respx(base_url=\"https://foo.bar\")\ndef test_configured_fixture(respx_mock):\n    respx_mock.get(\"/baz/\").mock(return_value=httpx.Response(204))\n    response = httpx.get(\"https://foo.bar/baz/\")\n    assert response.status_code == 204\n</code></pre> <p>See router configuration reference for more details.</p>"},{"location":"examples/#custom-fixtures","title":"Custom Fixtures","text":"<pre><code># conftest.py\nimport pytest\nimport respx\n\nfrom httpx import Response\n\n\n@pytest.fixture\ndef mocked_api():\n    with respx.mock(\n        base_url=\"https://foo.bar\", assert_all_called=False\n    ) as respx_mock:\n        users_route = respx_mock.get(\"/users/\", name=\"list_users\")\n        users_route.return_value = Response(200, json=[])\n        ...\n        yield respx_mock\n</code></pre> <pre><code># test_api.py\nimport httpx\n\n\ndef test_list_users(mocked_api):\n    response = httpx.get(\"https://foo.bar/users/\")\n    assert response.status_code == 200\n    assert response.json() == []\n    assert mocked_api[\"list_users\"].called\n</code></pre> <p>Session Scoped Fixtures</p> <p>If a session scoped RESPX fixture is used in an async context, you also need to broaden the <code>pytest-asyncio</code> event_loop fixture.  You can use the <code>session_event_loop</code> utility for this. </p> <pre><code># conftest.py\nimport pytest\nimport respx\n\nfrom respx.fixtures import session_event_loop as event_loop  # noqa: F401\n\n\n@pytest.fixture(scope=\"session\")\nasync def mocked_api(event_loop):  # noqa: F811\n    async with respx.mock(base_url=\"https://foo.bar\") as respx_mock:\n        ...\n        yield respx_mock\n</code></pre>"},{"location":"examples/#async-test-cases","title":"Async Test Cases","text":"<pre><code>import httpx\nimport respx\n\n\n@respx.mock\nasync def test_async_decorator():\n    async with httpx.AsyncClient() as client:\n        route = respx.get(\"https://example.org/\")\n        response = await client.get(\"https://example.org/\")\n        assert route.called\n        assert response.status_code == 200\n\n\nasync def test_async_ctx_manager():\n    async with respx.mock:\n        async with httpx.AsyncClient() as client:\n            route = respx.get(\"https://example.org/\")\n            response = await client.get(\"https://example.org/\")\n            assert route.called\n            assert response.status_code == 200\n</code></pre>"},{"location":"examples/#unittest","title":"unittest","text":""},{"location":"examples/#regular-decoration","title":"Regular Decoration","text":"<pre><code># test_api.py\nimport httpx\nimport respx\nimport unittest\n\n\nclass APITestCase(unittest.TestCase):\n    @respx.mock\n    def test_some_endpoint(self):\n        respx.get(\"https://example.org/\") % 202\n        response = httpx.get(\"https://example.org/\")\n        self.assertEqual(response.status_code, 202)\n</code></pre>"},{"location":"examples/#reuse-setup-teardown","title":"Reuse SetUp &amp; TearDown","text":"<pre><code># testcases.py\nimport respx\n\nfrom httpx import Response\n\n\nclass MockedAPIMixin:\n    @classmethod\n    def setUpClass(cls):\n        cls.mocked_api = respx.mock(\n            base_url=\"https://foo.bar\", assert_all_called=False\n        )\n        users_route = cls.mocked_api.get(\"/users/\", name=\"list_users\")\n        users_route.return_value = Response(200, json=[])\n        ...\n\n    def setUp(self):\n        self.mocked_api.start()\n        self.addCleanup(self.mocked_api.stop)\n</code></pre> <pre><code># test_api.py\nimport httpx\nimport unittest\n\nfrom .testcases import MockedAPIMixin\n\n\nclass APITestCase(MockedAPIMixin, unittest.TestCase):\n    def test_list_users(self):\n        response = httpx.get(\"https://foo.bar/users/\")\n        self.assertEqual(response.status_code, 200)\n        self.assertListEqual(response.json(), [])\n        self.assertTrue(self.mocked_api[\"list_users\"].called)\n</code></pre>"},{"location":"examples/#async-test-cases_1","title":"Async Test Cases","text":"<pre><code>import asynctest\nimport httpx\nimport respx\n\n\nclass MyTestCase(asynctest.TestCase):\n    @respx.mock\n    async def test_async_decorator(self):\n        async with httpx.AsyncClient() as client:\n            route = respx.get(\"https://example.org/\")\n            response = await client.get(\"https://example.org/\")\n            assert route.called\n            assert response.status_code == 200\n\n    async def test_async_ctx_manager(self):\n        async with respx.mock:\n            async with httpx.AsyncClient() as client:\n                route = respx.get(\"https://example.org/\")\n                response = await client.get(\"https://example.org/\")\n                assert route.called\n                assert response.status_code == 200\n</code></pre>"},{"location":"guide/","title":"User Guide","text":"<p>RESPX is a mock router, capturing requests sent by <code>HTTPX</code>, mocking their responses.</p> <p>Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups.</p> <p>Request patterns are bits of the request, like <code>host</code> <code>method</code> <code>path</code> etc,  with given lookup values, combined using bitwise operators to form a <code>Route</code>, i.e. <code>respx.route(path__regex=...)</code></p> <p>A captured request, matching a <code>Route</code>, resolves to a mocked <code>httpx.Response</code>, or triggers a given side effect. To skip mocking a specific request, a route can be marked to pass through.</p>"},{"location":"guide/#mock-httpx","title":"Mock HTTPX","text":"<p>To patch <code>HTTPX</code>, and activate the RESPX router, use the <code>respx.mock</code> decorator/context manager, or the  <code>respx_mock</code> pytest fixture.</p>"},{"location":"guide/#using-the-decorator","title":"Using the Decorator","text":"<pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_decorator():\n    my_route = respx.get(\"https://example.org/\")\n    response = httpx.get(\"https://example.org/\")\n    assert my_route.called\n    assert response.status_code == 200\n</code></pre>"},{"location":"guide/#using-the-context-manager","title":"Using the Context Manager","text":"<pre><code>import httpx\nimport respx\n\n\ndef test_ctx_manager():\n    with respx.mock:\n        my_route = respx.get(\"https://example.org/\")\n        response = httpx.get(\"https://example.org/\")\n        assert my_route.called\n        assert response.status_code == 200\n</code></pre>"},{"location":"guide/#using-the-pytest-fixture","title":"Using the pytest Fixture","text":"<pre><code>import httpx\n\n\ndef test_fixture(respx_mock):\n    my_route = respx_mock.get(\"https://example.org/\")\n    response = httpx.get(\"https://example.org/\")\n    assert my_route.called\n    assert response.status_code == 200\n</code></pre>"},{"location":"guide/#router-settings","title":"Router Settings","text":"<p>The RESPX router can be configured with built-in assertion checks and an optional base URL.</p> <p>By configuring, an isolated router is created, and settings are locally bound to the routes added.</p> <p>Either of the decorator, context manager and fixture takes the same configuration arguments. </p> <p>See router configuration reference for more details.</p> <p>Configure the Decorator</p> <p>When decorating a test case with configured router settings, the test function will receive the router instance as a <code>respx_mock</code> argument.</p> <pre><code>@respx.mock(...)\ndef test_something(respx_mock):\n    ...\n</code></pre> <p>Configure the Context Manager</p> <p>When passing settings to the context manager, the configured router instance will be yielded.</p> <pre><code>with respx.mock(...) as respx_mock:\n    ...\n</code></pre> <p>Configure the Fixture</p> <p>To configure the router when using the <code>pytest</code> fixture, decorate the test case with the <code>respx</code> pytest marker.</p> <pre><code>@pytest.mark.respx(...)\ndef test_something(respx_mock):\n    ...\n</code></pre>"},{"location":"guide/#base-url","title":"Base URL","text":"<p>When adding a lot of routes, sharing the same domain/prefix, you can configure the router with a <code>base_url</code> to be used for added routes.</p> <pre><code>import httpx\nimport respx\n\nfrom httpx import Response\n\n\n@respx.mock(base_url=\"https://example.org/api/\")\nasync def test_something(respx_mock):\n    async with httpx.AsyncClient(base_url=\"https://example.org/api/\") as client:\n        respx_mock.get(\"/baz/\").mock(return_value=Response(200, text=\"Baz\"))\n        response = await client.get(\"/baz/\")\n        assert response.text == \"Baz\"\n</code></pre>"},{"location":"guide/#assert-all-mocked","title":"Assert all Mocked","text":"<p>By default, asserts that all sent and captured <code>HTTPX</code> requests are routed and mocked.</p> <pre><code>@respx.mock(assert_all_mocked=True)\ndef test_something(respx_mock):\n    response = httpx.get(\"https://example.org/\")  # Not mocked, will raise\n</code></pre> <p>If disabled, all non-routed requests will be auto-mocked with status code <code>200</code>.</p> <pre><code>@respx.mock(assert_all_mocked=False)\ndef test_something(respx_mock):\n    response = httpx.get(\"https://example.org/\")  # Will auto-mock\n    assert response.status_code == 200\n</code></pre>"},{"location":"guide/#assert-all-called","title":"Assert all Called","text":"<p>By default, asserts that all added and mocked routes were called when exiting decorated test case, context manager scope or exiting a text case using the pytest fixture.</p> <pre><code>@respx.mock(assert_all_called=True)\ndef test_something(respx_mock):\n    respx_mock.get(\"https://example.org/\")\n    respx_mock.get(\"https://some.url/\")  # Not called, will fail the test\n\n    response = httpx.get(\"https://example.org/\")\n</code></pre> <pre><code>@respx.mock(assert_all_called=False)\ndef test_something(respx_mock):\n    respx_mock.get(\"https://example.org/\")\n    respx_mock.get(\"https://some.url/\")  # Not called, yet not asserted\n\n    response = httpx.get(\"https://example.org/\")\n    assert response.status_code == 200\n</code></pre>"},{"location":"guide/#routing-requests","title":"Routing Requests","text":"<p>The easiest way to add routes is to use the HTTP Method helpers.</p> <p>For full control over the request pattern matching, use the route API.</p> <p>Routes are matched and routed in added order. This means that routes with more specific patterns should to be added earlier than the ones with less \"details\".</p>"},{"location":"guide/#http-method-helpers","title":"HTTP Method Helpers","text":"<p>Each HTTP method has a helper function (<code>get</code>, <code>options</code>, <code>head</code>, <code>post</code>, <code>put</code>, <code>patch</code>, <code>delete</code>), shortcutting the route API.</p> <pre><code>my_route = respx.get(\"https://example.org/\", params={\"foo\": \"bar\"})\nresponse = httpx.get(\"https://example.org/\", params={\"foo\": \"bar\"})\nassert my_route.called\nassert response.status_code == 200\n</code></pre> <p>See .get(), .post(), ... helpers reference for more details.</p>"},{"location":"guide/#route-api","title":"Route API","text":""},{"location":"guide/#patterns","title":"Patterns","text":"<p>With the <code>route</code> API, you define a combined pattern to match, capturing a sent request.</p> <pre><code>my_route = respx.route(method=\"GET\", host=\"example.org\", path=\"/foobar/\")\nresponse = httpx.get(\"https://example.org/foobar/\")\nassert my_route.called\nassert response.status_code == 200\n</code></pre> <p>See .route() reference for more details.</p>"},{"location":"guide/#lookups","title":"Lookups","text":"<p>Each pattern has a default lookup. To specify what lookup to use, add a <code>__&lt;lookup&gt;</code> suffix.</p> <pre><code>respx.route(method__in=[\"PUT\", \"PATCH\"])\n</code></pre>"},{"location":"guide/#combining-patterns","title":"Combining Patterns","text":"<p>For even more flexibility, you can define combined patterns using the M() object, together with bitwise operators (<code>&amp;</code>, <code>|,</code> <code>~</code>), creating a reusable pattern.</p> <pre><code>hosts_pattern = M(host=\"example.org\") | M(host=\"example.com\")\nmy_route = respx.route(hosts_pattern, method=\"GET\", path=\"/foo/\")\n\nresponse = httpx.get(\"http://example.org/foo/\")\nassert response.status_code == 200\nassert my_route.called\n\nresponse = httpx.get(\"https://example.com/foo/\")\nassert response.status_code == 200\nassert my_route.call_count == 2\n</code></pre> <p>NOTE</p> <p><code>M(url=\"//example.org/foobar/\")</code> is equal to <code>M(host=\"example.org\") &amp; M(path=\"/foobar/\")</code></p>"},{"location":"guide/#named-routes","title":"Named Routes","text":"<p>Routes can be named when added, and later accessed through the <code>respx.routes</code> mapping.</p> <p>This is useful when a route is added outside the test case, e.g. access or assert route calls.</p> <pre><code>import httpx\nimport respx\n\n# Added somewhere else\nrespx.get(\"https://example.org/\", name=\"home\")\n\n\n@respx.mock\ndef test_route_call():\n    httpx.get(\"https://example.org/\")\n    assert respx.routes[\"home\"].called\n    assert respx.routes[\"home\"].call_count == 1\n\n    last_home_response = respx.routes[\"home\"].calls.last.response\n    assert last_home_response.status_code == 200\n</code></pre>"},{"location":"guide/#reusable-routers","title":"Reusable Routers","text":"<p>As described under settings, an isolated router is created when calling <code>respx.mock(...)</code>.</p> <p>Isolated routers are useful when mocking multiple remote APIs, allowing grouped routes per API, and to be mocked individually or stacked for reuse across tests.</p> <p>Use the router instance as decorator or context manager to patch <code>HTTPX</code> and activate the routes.</p> <pre><code>import httpx\nimport respx\n\napi_mock = respx.mock(base_url=\"https://api.foo.bar/\", assert_all_called=False)\napi_mock.get(\"/baz/\", name=\"baz\").mock(\n    return_value=httpx.Response(200, json={\"name\": \"baz\"}),\n)\n...\n\n\n@api_mock\ndef test_decorator():\n    response = httpx.get(\"https://api.foo.bar/baz/\")\n    assert response.status_code == 200\n    assert response.json() == {\"name\": \"baz\"}\n    assert api_mock[\"baz\"].called\n\n\ndef test_ctx_manager():\n    with api_mock:\n        ...\n</code></pre> <p>Catch-all</p> <p>Add a catch-all route last as a fallback for any non-matching request, e.g. <code>api_mock.route().respond(404)</code>.</p> <p>NOTE</p> <p>Named routes in a reusable router can be directly accessed via <code>my_mock_router[&lt;route name&gt;]</code></p>"},{"location":"guide/#route-with-an-app","title":"Route with an App","text":"<p>As an alternative one can route and mock responses with an <code>app</code> by passing either a <code>respx.WSGIHandler</code> or <code>respx.ASGIHandler</code> as side effect when mocking.</p> <p>Sync App Example</p> <pre><code>import httpx\nimport respx\n\nfrom flask import Flask\n\napp = Flask(\"foobar\")\n\n\n@app.route(\"/baz/\")\ndef baz():\n    return {\"ham\": \"spam\"}\n\n\n@respx.mock(base_url=\"https://foo.bar/\")\ndef test_baz(respx_mock):\n    app_route = respx_mock.route().mock(side_effect=WSGIHandler(app))\n    response = httpx.get(\"https://foo.bar/baz/\")\n    assert response.json() == {\"ham\": \"spam\"}\n    assert app_route.called\n</code></pre> <p>Async App Example</p> <pre><code>import httpx\nimport respx\n\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\n\nasync def baz(request):\n    return JSONResponse({\"ham\": \"spam\"})\n\n\napp = Starlette(routes=[Route(\"/baz/\", baz)])\n\n\n@respx.mock(base_url=\"https://foo.bar/\")\nasync def test_baz(respx_mock):\n    app_route = respx_mock.route().mock(side_effect=ASGIHandler(app))\n    response = await httpx.AsyncClient().get(\"https://foo.bar/baz/\")\n    assert response.json() == {\"ham\": \"spam\"}\n    assert app_route.called\n</code></pre>"},{"location":"guide/#mocking-responses","title":"Mocking Responses","text":"<p>To mock a route response, use <code>&lt;route&gt;.mock(...)</code> to either...</p> <ul> <li>set the <code>httpx.Response</code> to be returned.</li> <li>set a side effect to be triggered.</li> </ul> <p>The route's mock interface is inspired by pythons built-in <code>Mock()</code> object, e.g. <code>side_effect</code> has precedence over <code>return_value</code>, side effects can either be functions, exceptions or an iterable, raising <code>StopIteration</code> when \"exhausted\" etc.</p>"},{"location":"guide/#mock-a-response","title":"Mock a Response","text":"<p>Create a mocked <code>HTTPX</code> Response object and pass it as <code>return_value</code>.</p> <pre><code>respx.get(\"https://example.org/\").mock(return_value=Response(204))\n</code></pre> <p>See .mock() reference for more details.</p> <p>You can also use the <code>&lt;route&gt;.return_value</code> setter.</p> <pre><code>route = respx.get(\"https://example.org/\")\nroute.return_value = Response(200, json={\"foo\": \"bar\"})\n</code></pre>"},{"location":"guide/#mock-with-a-side-effect","title":"Mock with a Side Effect","text":"<p>RESPX side effects works just like the python <code>Mock</code> side effects.</p> <p>It can either be a function to call, an exception to raise, or an iterable of responses/exceptions to respond with in order, for repeated requests.</p> <pre><code>respx.get(\"https://example.org/\").mock(side_effect=...)\n</code></pre> <p>You can also use the <code>&lt;route&gt;.side_effect</code> setter.</p> <pre><code>route = respx.get(\"https://example.org/\")\nroute.side_effect = ...\n</code></pre>"},{"location":"guide/#functions","title":"Functions","text":"<p>Function side effects will be called with the captured <code>request</code> argument, and should either...</p> <ul> <li>return a mocked Response.</li> <li>raise an <code>Exception</code> to simulate a request error.</li> <li>return <code>None</code> to treat the route as a non-match, continuing testing further routes.</li> <li>return the input <code>Request</code> to pass through.</li> </ul> <pre><code>import httpx\nimport respx\n\n\ndef my_side_effect(request):\n    return httpx.Response(201)\n\n\n@respx.mock\ndef test_side_effect():\n    respx.post(\"https://example.org/\").mock(side_effect=my_side_effect)\n\n    response = httpx.post(\"https://example.org/\")\n    assert response.status_code == 201\n</code></pre> <p>Optionally, a side effect can include a <code>route</code> argument for cases where call stats, or modifying the route within the side effect, is needed.</p> <pre><code>import httpx\nimport respx\n\n\ndef my_side_effect(request, route):\n    return httpx.Response(201, json={\"id\": route.call_count + 1})\n\n\n@respx.mock\ndef test_side_effect():\n    respx.post(\"https://example.org/\").mock(side_effect=my_side_effect)\n\n    response = httpx.post(\"https://example.org/\")\n    assert response.json() == {\"id\": 1}\n\n    response = httpx.post(\"https://example.org/\")\n    assert response.json() == {\"id\": 2}\n</code></pre> <p>If any of the route patterns are using a regex lookup, containing named groups, the regex groups will be passed as kwargs to the side effect.</p> <pre><code>import httpx\nimport respx\n\n\ndef my_side_effect(request, slug):\n    return httpx.Response(200, json={\"slug\": slug})\n\n\n@respx.mock\ndef test_side_effect_kwargs():\n    route = respx.route(url__regex=r\"https://example.org/(?P&lt;slug&gt;\\w+)/\")\n    route.side_effect = my_side_effect\n\n    response = httpx.get(\"https://example.org/foobar/\")\n    assert response.status_code == 200\n    assert response.json() == {\"slug\": \"foobar\"}\n</code></pre> <p>A route can even decorate the function to be used as side effect.</p> <pre><code>import httpx\nimport rexpx\n\n\n@respx.route(url__regex=r\"https://example.org/(?P&lt;user&gt;\\w+)/\", name=\"user\")\ndef user_api(request, user):\n    return httpx.Response(200, json={\"user\": user})\n\n\n@respx.mock\ndef test_user_api():\n    response = httpx.get(\"https://example.org/lundberg/\")\n    assert response.status_code == 200\n    assert response.json() == {\"user\": \"lundberg\"}\n    assert respx.routes[\"user\"].called\n</code></pre>"},{"location":"guide/#exceptions","title":"Exceptions","text":"<p>To simulate a request error, pass a httpx.HTTPError subclass, or any <code>Exception</code>  as side effect.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_connection_error():\n    respx.get(\"https://example.org/\").mock(side_effect=httpx.ConnectError)\n\n    with pytest.raises(httpx.ConnectError):\n        httpx.get(\"https://example.org/\")\n</code></pre>"},{"location":"guide/#iterable","title":"Iterable","text":"<p>If the side effect is an iterable, each repeated request will get the next Response returned, or exception raised, from the iterable.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_stacked_responses():\n    route = respx.get(\"https://example.org/\")\n    route.side_effect = [\n        httpx.Response(404),\n        httpx.Response(200),\n    ]\n\n    response1 = httpx.get(\"https://example.org/\")\n    response2 = httpx.get(\"https://example.org/\")\n\n    assert response1.status_code == 404\n    assert response2.status_code == 200\n    assert route.call_count == 2\n</code></pre> <p>Like python <code>Mock</code> side effects, <code>StopIteration</code> will be raised once the iterable is exhausted. A more practical use case is to have the last entry infinitely repeated, which can be done by utilizing <code>itertools</code>.</p> <pre><code>from itertools import chain, repeat\nimport httpx\nimport respx\n\n\n@respx.mock\ndef test_stacked_responses():\n    respx.post(\"https://example.org/\").mock(\n        side_effect=chain(\n            [httpx.Response(201)],\n            repeat(httpx.Response(200)),\n        )\n    )\n\n    response1 = httpx.post(\"https://example.org/\")\n    response2 = httpx.post(\"https://example.org/\")\n    response3 = httpx.post(\"https://example.org/\")\n\n    assert response1.status_code == 201\n    assert response2.status_code == 200\n    assert response3.status_code == 200\n</code></pre>"},{"location":"guide/#shortcuts","title":"Shortcuts","text":""},{"location":"guide/#respond","title":"Respond","text":"<p>For convenience, <code>&lt;route&gt;.respond(...)</code> can be used as a shortcut to <code>return_value</code>.</p> <pre><code>respx.post(\"https://example.org/\").respond(201)\n</code></pre> <p>See .respond() reference for more details.</p>"},{"location":"guide/#modulo","title":"Modulo","text":"<p>For simple mocking, a quick way is to use the python modulo (<code>%</code>) operator to mock the response.</p> <p>The right-hand modulo argument can either be ...</p> <p>An <code>int</code> representing the <code>status_code</code> to mock:</p> <pre><code>respx.get(\"https://example.org/\") % 204\n\nresponse = httpx.get(\"https://example.org/\")\nassert response.status_code == 204\n</code></pre> <p>A <code>dict</code> used as kwargs to create a mocked <code>HTTPX</code> Response, with status code <code>200</code> by default:</p> <pre><code>respx.get(\"https://example.org/\") % dict(json={\"foo\": \"bar\"})\n\nresponse = httpx.get(\"https://example.org/\")\nassert response.status_code == 200\nassert response.json() == {\"foo\": \"bar\"}\n</code></pre> <p>A <code>HTTPX</code> Response object:</p> <pre><code>respx.get(\"https://example.org/\") % Response(418)\n\nresponse = httpx.get(\"https://example.org/\")\nassert response.status_code == httpx.codes.IM_A_TEAPOT\n</code></pre>"},{"location":"guide/#rollback","title":"Rollback","text":"<p>When exiting a decorated test case, or context manager, the routes and their mocked values, i.e. <code>return_value</code> and <code>side_effect</code>, will be rolled back and restored to their initial state.</p> <p>This means that you can safely modify existing routes, or add new ones, within a test case, without affecting other tests that are using the same router.</p> <pre><code>import httpx\nimport respx\n\n# Initial routes\nmock_router = respx.mock(base_url=\"https://example.org\")\nmock_router.get(path__regex=\"/user/(?P&lt;pk&gt;\\d+)/\", name=\"user\") % 404\n...\n\n\n@mock_router\ndef test_user_exists():\n    # This change will be rolled back after this test case\n    mock_router[\"user\"].return_value = httpx.Response(200)\n\n    response = httpx.get(\"https://example.org/user/123/\")\n    assert response.status_code == 200\n\n\n@mock_router\ndef test_user_not_found():\n    response = httpx.get(\"https://example.org/user/123/\")\n    assert response.status_code == 404\n</code></pre>"},{"location":"guide/#pass-through","title":"Pass Through","text":"<p>If you want a route to not capture and mock a request response, use <code>.pass_through()</code>.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_remote_response():\n    respx.route(host=\"localhost\").pass_through()\n    response = httpx.get(\"http://localhost:8000/\")  # response from server\n</code></pre> <p>See .pass_through() reference for more details.</p>"},{"location":"guide/#mock-without-patching-httpx","title":"Mock without patching HTTPX","text":"<p>If you don't need to patch <code>HTTPX</code>, use <code>httpx.MockTransport</code> with a REPX router as handler, when instantiating your client.</p> <pre><code>import httpx\nimport respx\n\n\nrouter = respx.Router()\nrouter.post(\"https://example.org/\") % 404\n\n\ndef test_client():\n    mock_transport = httpx.MockTransport(router.handler)\n    with httpx.Client(transport=mock_transport) as client:\n        response = client.post(\"https://example.org/\")\n        assert response.status_code == 404\n\n\ndef test_client():\n    mock_transport = httpx.MockTransport(router.async_handler)\n    with httpx.AsyncClient(transport=mock_transport) as client:\n        ...\n</code></pre> <p>NOTE</p> <p>To assert all routes is called, you'll need to trigger  <code>&lt;router&gt;.assert_all_called()</code> manually, e.g. in a test case or after yielding the  router in a pytest fixture, since there's no auto post assertion done like  when using respx.mock.</p> <p>Hint</p> <p>You can use <code>RESPX</code> not only to mock out <code>HTTPX</code>, but actually mock any library using <code>HTTP Core</code> transports.</p>"},{"location":"guide/#call-history","title":"Call History","text":"<p>The <code>respx</code> API includes a <code>.calls</code> object, containing captured (<code>request</code>, <code>response</code>) named tuples and MagicMock's bells and whistles, i.e. <code>call_count</code>, <code>assert_called</code> etc.</p>"},{"location":"guide/#asserting-calls","title":"Asserting calls","text":"<pre><code>assert respx.calls.called\nassert respx.calls.call_count == 1\n\nrespx.calls.assert_called()\nrespx.calls.assert_not_called()\nrespx.calls.assert_called_once()\n</code></pre>"},{"location":"guide/#retrieving-mocked-calls","title":"Retrieving mocked calls","text":"<p>A matched and mocked <code>Call</code> can be retrieved from call history, by either unpacking...</p> <pre><code>request, response = respx.calls.last\nrequest, response = respx.calls[-2]  # by call order\n</code></pre> <p>...or by accessing <code>request</code> or <code>response</code> directly...</p> <pre><code>last_request = respx.calls.last.request\nassert json.loads(last_request.content) == {\"foo\": \"bar\"}\n\nlast_response = respx.calls.last.response\nassert last_response.status_code == 200\n</code></pre>"},{"location":"guide/#local-route-calls","title":"Local route calls","text":"<p>Each <code>Route</code> object has its own <code>.calls</code>, along with <code>.called</code> and <code>.call_count</code> shortcuts.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_route_call_stats():\n    route = respx.post(\"https://example.org/baz/\") % 201\n    httpx.post(\"https://example.org/baz/\")\n\n    assert route.calls.last.request.url.path == \"/baz/\"\n    assert route.calls.last.response.status_code == 201\n\n    assert route.called\n    assert route.call_count == 1\n\n    route.calls.assert_called_once()\n</code></pre>"},{"location":"guide/#reset-history","title":"Reset History","text":"<p>The call history will automatically reset when exiting mocked context, i.e. leaving a decorated test case, or context manager scope.</p> <p>To manually reset call stats during a test case, use <code>respx.reset()</code> or <code>&lt;your_router&gt;.reset()</code>.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_reset():\n    respx.post(\"https://foo.bar/baz/\")\n    httpx.post(\"https://foo.bar/baz/\")\n\n    assert respx.calls.call_count == 1\n    respx.calls.assert_called_once()\n\n    respx.reset()\n\n    assert len(respx.calls) == 0\n    assert respx.calls.call_count == 0\n    respx.calls.assert_not_called()\n</code></pre>"},{"location":"migrate/","title":"Migrate from requests","text":""},{"location":"migrate/#responses","title":"responses","text":"<p>Here's a few examples on how to migrate your code from the <code>responses</code> library to <code>respx</code>.</p>"},{"location":"migrate/#patching-the-client","title":"Patching the Client","text":""},{"location":"migrate/#decorator","title":"Decorator","text":"<pre><code>@responses.activate\ndef test_foo():\n    ...\n</code></pre> <pre><code>@respx.mock\ndef test_foo():\n    ...\n</code></pre> <p>See Router Settings for more details.</p>"},{"location":"migrate/#context-manager","title":"Context Manager","text":"<pre><code>def test_foo():\n    with responses.RequestsMock() as rsps:\n        ...\n</code></pre> <pre><code>def test_foo():\n    with respx.mock() as respx_mock:\n        ...\n</code></pre> <p>See Router Settings for more details.</p>"},{"location":"migrate/#unittest-setup","title":"unittest setUp","text":"<pre><code>def setUp(self):\n    self.responses = responses.RequestsMock()\n    self.responses.start()\n    self.addCleanup(self.responses.stop)\n</code></pre> <pre><code>def setUp(self):\n    self.respx_mock = respx.mock()\n    self.respx_mock.start()\n    self.addCleanup(self.respx_mock.stop)\n</code></pre> <p>See unittest examples for more details.</p>"},{"location":"migrate/#mock-a-response","title":"Mock a Response","text":"<pre><code>responses.add(\n    responses.GET, \"https://example.org/\",\n    json={\"foo\": \"bar\"},\n    status=200,\n)\n</code></pre> <pre><code>respx.get(\"https://example.org/\").respond(200, json={\"foo\": \"bar\"})\n</code></pre> <p>See Routing Requests and Mocking Responses for more details.</p>"},{"location":"migrate/#mock-an-exception","title":"Mock an Exception","text":"<pre><code>responses.add(\n    responses.GET, \"https://example.org/\",\n    body=Exception(\"...\"),\n)\n</code></pre> <pre><code>respx.get(\"https://example.org/\").mock(side_effect=ConnectError)\n</code></pre> <p>See Exception Side Effect for more details.</p>"},{"location":"migrate/#subsequent-responses","title":"Subsequent Responses","text":"<pre><code>responses.add(responses.GET, \"https://example.org/\", status=200)\nresponses.add(responses.GET, \"https://example.org/\", status=500)\n</code></pre> <pre><code>respx.get(\"https://example.org/\").mock(\n    side_effect=[Response(200), Response(500)]\n)\n</code></pre> <p>See Iterable Side Effect for more details.</p>"},{"location":"migrate/#callbacks","title":"Callbacks","text":"<pre><code>def my_callback(request):\n    headers = {\"Content-Type\": \"application/json\"}\n    body = {\"foo\": \"bar\"}\n    return (200, headers, json.dumps(resp_body))\n\nresponses.add_callback(\n    responses.GET, \"http://example.org/\",\n    callback=my_callback,\n)\n</code></pre> <pre><code>def my_side_effect(request, route):\n    return Response(200, json={\"foo\": \"bar\"})\n\nrespx.get(\"https://example.org/\").mock(side_effect=my_side_effect)\n</code></pre> <p>See Mock with a Side Effect for more details.</p>"},{"location":"migrate/#history-and-assertions","title":"History and Assertions","text":""},{"location":"migrate/#history","title":"History","text":"<pre><code>responses.calls[0].request\nresponses.calls[0].response\n</code></pre> <pre><code>respx.calls[0].request\nrespx.calls[0].response\n\nrequest, response = respx.calls[0]\nrespx.calls.last.response\n</code></pre> <p>See Call History for more details.</p>"},{"location":"migrate/#call-count","title":"Call Count","text":"<pre><code>responses.assert_call_count(\"http://example.org/\", 1)\n</code></pre> <pre><code>route = respx.get(\"https://example.org/\")\nassert route.call_count == 1\n</code></pre> <p>See Call History for more details.</p>"},{"location":"migrate/#all-called","title":"All Called","text":"<pre><code>with responses.RequestsMock(assert_all_requests_are_fired=False) as rsps:\n    ...\n</code></pre> <pre><code>with respx.mock(assert_all_called=False) as respx_mock:\n    ...\n</code></pre> <p>See Assert all Called for more details.</p>"},{"location":"migrate/#modify-mocked-response","title":"Modify Mocked Response","text":"<pre><code>responses.add(responses.GET, \"http://example.org/\", json={\"data\": 1})\nresponses.replace(responses.GET, \"http://example.org/\", json={\"data\": 2})\n</code></pre> <pre><code>respx.get(\"https://example.org/\").respond(json={\"data\": 1})\nrespx.get(\"https://example.org/\").respond(json={\"data\": 2})\n</code></pre>"},{"location":"migrate/#pass-through-requests","title":"Pass Through Requests","text":"<pre><code>responses.add_passthru(\"https://example.org/\")\n</code></pre> <pre><code>respx.route(url=\"https://example.org/\").pass_through()\n</code></pre> <p>See Pass Through for more details.</p>"},{"location":"migrate/#requests-mock","title":"requests-mock","text":"<p>todo ... contribution welcome ;-)</p>"},{"location":"mocking/","title":"Mock HTTPX","text":"<p>RESPX is a mock router, capturing requests sent by <code>HTTPX</code>, mocking their responses.</p> <p>Inspired by the flexible query API of the Django ORM, requests are filtered and matched against routes and their request patterns and lookups.</p> <p>Request patterns are bits of the request, like <code>host</code> <code>method</code> <code>path</code> etc,  with given lookup values, combined using bitwise operators to form a <code>Route</code>, i.e. <code>respx.route(path__regex=...)</code></p> <p>A captured request, matching a <code>Route</code>, resolves to a mocked <code>httpx.Response</code>, or triggers a given side effect. To skip mocking a specific request, a route can be marked to pass through.</p> <p>Read the User Guide for a complete walk-through.</p>"},{"location":"upgrade/","title":"Upgrade Guide","text":"<p>As of RESPX version <code>0.15.0</code>, the API has changed, but kept with deprecation warnings, later to be broken for backward compatibility in <code>0.16.0</code>.</p> <p>The biggest change involved separating request pattern arguments from response details.</p> <p>This brings the RESPX request matching API closer to the <code>HTTPX</code> client API, and the response mocking aligned with the python <code>Mock</code> API.</p>"},{"location":"upgrade/#responses","title":"Responses","text":"<p>Response details are now mocked separatelty:</p> <pre><code># Previously\nrespx.post(\"https://some.url/\", status_code=200, content={\"x\": 1})\n\n# Now\nrespx.post(\"https://some.url/\").mock(return_value=Response(200, json={\"x\": 1}))\nrespx.post(\"https://some.url/\").respond(200, json={\"x\": 1})\nrespx.post(\"https://some.url/\") % dict(json={\"x\": 1})\n</code></pre> <p>The <code>.add</code> API has changed to <code>.route</code>:</p> <pre><code># Previously\nrespx.add(\"POST\", \"https://some.url/\", content=\"foobar\")\n\n# Now\nrespx.route(method=\"POST\", url=\"https://some.url/\").respond(content=\"foobar\")\n</code></pre>"},{"location":"upgrade/#callbacks","title":"Callbacks","text":"<p>Callbacks and simulated errors are now side effects:</p> <pre><code># Previously\nrespx.post(\"https://some.url/\", content=callback)\nrespx.post(\"https://some.url/\", content=Exception())\nrespx.add(callback)\n\n# Now\nrespx.post(\"https://some.url/\").mock(side_effect=callback)\nrespx.post(\"https://some.url/\").mock(side_effect=Exception)\nrespx.route().mock(side_effect=callback)\n</code></pre>"},{"location":"upgrade/#stacking","title":"Stacking","text":"<p>Repeating a mocked response, for stacking, is now solved with side effects:</p> <pre><code># Previously\nrespx.post(\"https://some.url/\", status_code=404)\nrespx.post(\"https://some.url/\", status_code=200)\n\n# Now\nrespx.post(\"https://some.url/\").mock(\n    side_effect=[\n        Response(404),\n        Response(200),\n    ],\n)\n</code></pre> <p>Note: Repeating a route in <code>0.15.0+</code> replaces any existing route with same pattern.</p>"},{"location":"upgrade/#aliasing","title":"Aliasing","text":"<p>Aliases changed to named routes:</p> <pre><code># Previously\nrespx.post(\"https://example.org/\", alias=\"example\")\nassert respx.aliases[\"example\"].called\n\n# Now\nrespx.post(\"https://example.org/\", name=\"example\")\nassert respx.routes[\"example\"].called\n</code></pre>"},{"location":"upgrade/#history","title":"History","text":"<p>Call history renamed:</p> <pre><code># Previously\nassert respx.stats.call_count == 1\n\n# Now\nassert respx.calls.call_count == 1\n</code></pre>"},{"location":"upgrade/#mocktransport","title":"MockTransport","text":"<p>The <code>respx.MockTransport</code> should no longer be used as a mock router, use <code>respx.mock(...)</code>.</p> <pre><code># Previously\nmy_mock = respx.MockTransport(assert_all_called=False)\n\n# Now\nmy_mock = respx.mock(assert_all_called=False)\n</code></pre>"},{"location":"versions/0.14.0/api/","title":"Developer Interface","text":"<p>Warning</p> <p>This is the documentation of the older version <code>0.14.0</code>. See latest for current release.</p>"},{"location":"versions/0.14.0/api/#developer-interface-version-0140","title":"Developer Interface - Version 0.14.0","text":""},{"location":"versions/0.14.0/api/#mocking-responses","title":"Mocking Responses","text":""},{"location":"versions/0.14.0/api/#http-method-api","title":"HTTP Method API","text":"<p>For regular and simple use, use the HTTP method shorthands. See Request API for parameters.</p> <code>respx.get</code>(url=None, *, name=None, **lookups) <p><code>respx.options(...)</code></p> <p><code>respx.head(...)</code></p> <p><code>respx.post(...)</code></p> <p><code>respx.put(...)</code></p> <p><code>respx.patch(...)</code></p> <p><code>respx.delete(...)</code></p>"},{"location":"versions/0.14.0/api/#request-api","title":"Request API","text":"<p>For full control, use the core <code>add</code> method.</p> <code>respx.add</code>(route, *, name=None) <p>Parameters:</p> <ul> <li>method - str | callable | RequestPattern   Request HTTP method, or Request callback, to match.</li> <li>url - (optional) str | pattern | tuple (httpcore) | httpx.URL   Request exact URL, or URL pattern, to match.</li> <li>params - (optional) str | list | dict   Request URL params to merge with url.</li> <li>status_code - (optional) int - default: <code>200</code>   Response status code to mock.</li> <li>headers - (optional) dict   Response headers to mock.</li> <li>content_type - (optional) str   Response Content-Type header value to mock.</li> <li>content - (optional) bytes | str | list | dict | callable | exception - default <code>b\"\"</code>   Response content to mock. - See Response Content.</li> <li>text - (optional) str   Response text content to mock, with automatic content type header.</li> <li>html - (optional) str   Response html content to mock, with automatic content type header.</li> <li>json - (optional) str | list | dict   Response json content to mock, with automatic content type header.</li> <li>pass_through - (optional) bool - default <code>False</code>   Mark matched request to pass-through to real server, e.g. don't mock.</li> <li>alias - (optional) str   Name this request pattern. - See Call Statistics.</li> </ul>"},{"location":"versions/0.14.0/api/#matching-requests","title":"Matching Requests","text":""},{"location":"versions/0.14.0/api/#exact-url","title":"Exact URL","text":"<p>To match and mock a request by an exact URL, pass the <code>url</code> parameter as a string.</p> <pre><code>respx.get(\"https://foo.bar/\", status_code=204)\n</code></pre>"},{"location":"versions/0.14.0/api/#url-pattern","title":"URL pattern","text":"<p>Instead of matching an exact URL, you can pass a compiled regex to match the request URL.</p> <pre><code>import httpx\nimport re\nimport respx\n\n\n@respx.mock\ndef test_something():\n    url_pattern = re.compile(r\"^https://foo.bar/\\w+/$\")\n    respx.get(url_pattern, content=\"Baz\")\n    response = httpx.get(\"https://foo.bar/baz/\")\n    assert response.text == \"Baz\"\n</code></pre> <p>Tip</p> <p>Named groups in the regex pattern will be passed as <code>kwargs</code> to the response content callback, if used.</p>"},{"location":"versions/0.14.0/api/#base-url","title":"Base URL","text":"<p>When adding a lot of request patterns sharing the same domain/prefix, you can configure RESPX with a <code>base_url</code> to use as the base when matching URLs.</p> <p>Like <code>url</code>, the <code>base_url</code> can also be passed as a compiled regex, with optional named groups.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock(base_url=\"https://foo.bar\")\nasync def test_something(respx_mock):\n    async with httpx.AsyncClient(base_url=\"https://foo.bar\") as client:\n        request = respx_mock.get(\"/baz/\", content=\"Baz\")\n        response = await client.get(\"/baz/\")\n        assert response.text == \"Baz\"\n</code></pre>"},{"location":"versions/0.14.0/api/#request-callback","title":"Request callback","text":"<p>For full control of what request to match and what response to mock, pass a callback function as the <code>add(method, ...)</code> parameter. The callback's response argument will be pre-populated with any additional response parameters.</p> <pre><code>import httpx\nimport respx\n\n\ndef match_and_mock(request, response):\n    \"\"\"\n    Return `None` to not match the request.\n    Return the `response` to match and mock this request.\n    Return the `request` for pass-through behaviour.\n    \"\"\"\n    if request.method != \"POST\":\n        return None\n\n    if \"X-Auth-Token\" not in request.headers:\n        response.status_code = 401\n    else:\n        response.content = \"OK\"\n\n    return response\n\n\n@respx.mock\ndef test_something():\n    custom_request = respx.add(match_and_mock, status_code=201)\n    respx.get(\"https://foo.bar/baz/\")\n\n    response = httpx.get(\"https://foo.bar/baz/\")\n    assert response.status_code == 200\n    assert not custom_request.called\n\n    response = httpx.post(\"https://foo.bar/baz/\")\n    assert response.status_code == 401\n    assert custom_request.called\n\n    response = httpx.post(\"https://foo.bar/baz/\", headers={\"X-Auth-Token\": \"x\"})\n    assert response.status_code == 201\n    assert custom_request.call_count == 2\n</code></pre>"},{"location":"versions/0.14.0/api/#repeated-patterns","title":"Repeated patterns","text":"<p>If you mock several responses with the same request pattern, they will be matched in order, and popped til the last one.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_something():\n    respx.get(\"https://foo.bar/baz/123/\", status_code=404)\n    respx.get(\"https://foo.bar/baz/123/\", content={\"id\": 123})\n    respx.post(\"https://foo.bar/baz/\", status_code=201)\n\n    response = httpx.get(\"https://foo.bar/baz/123/\")\n    assert response.status_code == 404  # First match\n\n    response = httpx.post(\"https://foo.bar/baz/\")\n    assert response.status_code == 201\n\n    response = httpx.get(\"https://foo.bar/baz/123/\")\n    assert response.status_code == 200  # Second match\n    assert response.json() == {\"id\": 123}\n</code></pre>"},{"location":"versions/0.14.0/api/#manipulating-existing-patterns","title":"Manipulating Existing Patterns","text":"<p>Clearing all existing patterns:</p> <pre><code>import respx\n\n\n@respx.mock\ndef test_something():\n    respx.get(\"https://foo.bar/baz\", status_code=404)\n    respx.clear()  # no patterns will be matched after this call\n</code></pre> <p>Removing and optionally re-using an existing pattern by alias:</p> <pre><code>import respx\n\n\n@respx.mock\ndef test_something():\n    respx.get(\"https://foo.bar/\", status_code=404, alias=\"index\")\n    request_pattern = respx.pop(\"index\")\n    respx.get(request_pattern.url, status_code=200)\n</code></pre>"},{"location":"versions/0.14.0/api/#response-content","title":"Response Content","text":""},{"location":"versions/0.14.0/api/#json-content","title":"JSON content","text":"<p>To mock a response with json content, pass a <code>list</code> or a <code>dict</code>. The <code>Content-Type</code> header will automatically be set to <code>application/json</code>.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_something():\n    respx.get(\"https://foo.bar/baz/123/\", content={\"id\": 123})\n    response = httpx.get(\"https://foo.bar/baz/123/\")\n    assert response.json() == {\"id\": 123}\n</code></pre>"},{"location":"versions/0.14.0/api/#content-callback","title":"Content callback","text":"<p>If you need dynamic response content, pass a callback function. When used together with a URL pattern, named groups will be passed as <code>kwargs</code>.</p> <pre><code>import httpx\nimport re\nimport respx\n\n\ndef some_content(request, slug=None):\n    \"\"\" Return bytes, str, list or a dict. \"\"\"\n    return {\"slug\": slug}\n\n\n@respx.mock\ndef test_something():\n    url_pattern = r\"^https://foo.bar/(?P&lt;slug&gt;\\w+)/$\")\n    respx.get(url_pattern, content=some_content)\n\n    response = httpx.get(\"https://foo.bar/apa/\")\n    assert response.json() == {\"slug\": \"apa\"}\n</code></pre>"},{"location":"versions/0.14.0/api/#request-error","title":"Request Error","text":"<p>To simulate a failing request, like a connection error, pass an <code>Exception</code> instance. This is useful when you need to test proper <code>HTTPX</code> error handling in your app.</p> <pre><code>import httpx\nimport httpcore\nimport respx\n\n\n@respx.mock\ndef test_something():\n    respx.get(\"https://foo.bar/\", content=httpcore.ConnectTimeout())\n    response = httpx.get(\"https://foo.bar/\")  # Will raise\n</code></pre>"},{"location":"versions/0.14.0/api/#built-in-assertions","title":"Built-in Assertions","text":"<p>RESPX has the following built-in assertion checks:</p> <ul> <li>assert_all_mocked   Asserts that all captured <code>HTTPX</code> requests are mocked. Defaults to <code>True</code>.</li> <li>assert_all_called   Asserts that all mocked request patterns were called. Defaults to <code>True</code>.</li> </ul> <p>Configure checks by using the <code>respx.mock</code> decorator / context manager with parentheses.</p> <pre><code>@respx.mock(assert_all_called=False)\ndef test_something(respx_mock):\n    respx_mock.get(\"https://some.url/\")  # OK\n    respx_mock.get(\"https://foo.bar/\")\n\n    response = httpx.get(\"https://foo.bar/\")\n    assert response.status_code == 200\n    assert respx_mock.calls.call_count == 1\n</code></pre> <pre><code>with respx.mock(assert_all_mocked=False) as respx_mock:\n    response = httpx.get(\"https://foo.bar/\")  # OK\n    assert response.status_code == 200\n    assert respx_mock.calls.call_count == 1\n</code></pre> <p>Without Parentheses</p> <p>When using the global scope <code>@respx.mock</code> decorator / context manager, <code>assert_all_called</code> is disabled.</p>"},{"location":"versions/0.14.0/api/#call-history","title":"Call History","text":"<p>The <code>respx</code> API includes a <code>.calls</code> object, containing captured (<code>request</code>, <code>response</code>) named tuples and MagicMock's bells and whistles, i.e. <code>call_count</code>, <code>assert_called</code> etc.</p>"},{"location":"versions/0.14.0/api/#retrieving-mocked-calls","title":"Retrieving mocked calls","text":"<p>A matched and mocked <code>Call</code> can be retrieved from call history, by either unpacking...</p> <pre><code>request, response = respx.calls.last\nrequest, response = respx.calls[-2]  # by call order\n</code></pre> <p>...or by accessing <code>request</code> or <code>response</code> directly...</p> <pre><code>last_response = respx.calls.last.response\n\nassert respx.calls.last.request.call_count == 1\nassert respx.calls.last.response.status_code == 200\n</code></pre> <p>Deprecation Warning</p> <p>As of version <code>0.14.0</code>, statistics via <code>respx.stats</code> is deprecated, in favour of <code>respx.calls</code>.</p>"},{"location":"versions/0.14.0/api/#request-pattern-calls","title":"Request Pattern calls","text":"<p>Each mocked response request pattern has its own <code>.calls</code>, along with <code>.called</code> and <code>.call_count</code> stats shortcuts.</p> <p>Example using locally added request pattern:</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_something():\n    request = respx.post(\"https://foo.bar/baz/\", status_code=201)\n    httpx.post(\"https://foo.bar/baz/\")\n    assert request.called\n    assert request.call_count == 1\n    assert request.calls.last.response.status_code == 201\n    request.calls.assert_called_once()\n</code></pre> <p>Example using globally aliased request pattern:</p> <pre><code>import httpx\nimport respx\n\n# Added somewhere outside the test\nrespx.get(\"https://foo.bar/\", alias=\"index\")\n\n@respx.mock\ndef test_something():\n    httpx.get(\"https://foo.bar/\")\n    assert respx.aliases[\"index\"].called\n    assert respx.aliases[\"index\"].call_count == 1\n    last_index_response = respx.aliases[\"index\"].calls.last.response\n</code></pre>"},{"location":"versions/0.14.0/api/#reset-stats","title":"Reset stats","text":"<p>To reset stats during a test case, without stop mocking, use <code>respx.reset()</code>.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_something():\n    respx.post(\"https://foo.bar/baz/\")\n    httpx.post(\"https://foo.bar/baz/\")\n    assert respx.calls.call_count == 1\n    request.calls.assert_called_once()\n\n    respx.reset()\n    assert len(respx.calls) == 0\n    assert respx.calls.call_count == 0\n    respx.calls.assert_not_called()\n</code></pre>"},{"location":"versions/0.14.0/api/#examples","title":"Examples","text":"<p>Here's a handful example usages of the call stats API.</p> <pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_something():\n    # Mock some calls\n    respx.get(\"https://foo.bar/\", alias=\"index\")\n    baz_request = respx.post(\"https://foo.bar/baz/\", status_code=201)\n\n    # Make some calls\n    httpx.get(\"https://foo.bar/\")\n    httpx.post(\"https://foo.bar/baz/\")\n\n    # Assert mocked\n    assert respx.aliases[\"index\"].called\n    assert respx.aliases[\"index\"].call_count == 1\n\n    assert baz_request.called\n    assert baz_request.call_count == 1\n    baz_request.calls.assert_called_once()\n\n    # Global stats increased\n    assert respx.calls.call_count == 2\n\n    # Assert responses\n    assert respx.aliases[\"index\"].calls.last.response.status_code == 200\n    assert respx.calls.last.response is baz_request.calls.last.response\n    assert respx.calls.last.response.status_code == 201\n\n    # Reset\n    respx.reset()\n    assert len(respx.calls) == 0\n    assert respx.calls.call_count == 0\n    respx.calls.assert_not_called()\n</code></pre>"},{"location":"versions/0.14.0/mocking/","title":"Mock HTTPX","text":"<p>Warning</p> <p>This is the documentation of the older version <code>0.14.0</code>. See latest for current release.</p>"},{"location":"versions/0.14.0/mocking/#mock-httpx-version-0140","title":"Mock HTTPX - Version 0.14.0","text":"<p>To mock out <code>HTTPX</code> and/or <code>HTTP Core</code>, use the <code>respx.mock</code> decorator / context manager.</p> <p>Optionally configure built-in assertion checks and base URL with <code>respx.mock(...)</code>.</p>"},{"location":"versions/0.14.0/mocking/#using-the-decorator","title":"Using the Decorator","text":"<pre><code>import httpx\nimport respx\n\n\n@respx.mock\ndef test_something():\n    request = respx.get(\"https://foo.bar/\", content=\"foobar\")\n    response = httpx.get(\"https://foo.bar/\")\n    assert request.called\n    assert response.status_code == 200\n    assert response.text == \"foobar\"\n</code></pre>"},{"location":"versions/0.14.0/mocking/#using-the-context-manager","title":"Using the Context Manager","text":"<pre><code>import httpx\nimport respx\n\n\nwith respx.mock:\n    request = respx.get(\"https://foo.bar/\", content=\"foobar\")\n    response = httpx.get(\"https://foo.bar/\")\n    assert request.called\n    assert response.status_code == 200\n    assert response.text == \"foobar\"\n</code></pre> <p>NOTE</p> <p>You can also start and stop mocking <code>HTTPX</code> manually, by calling <code>respx.start()</code> and <code>respx.stop()</code>.</p>"},{"location":"versions/0.14.0/mocking/#using-the-mock-transports","title":"Using the mock Transports","text":"<p>The built-in transports are the base of all mocking and patching in RESPX.</p> <p>In fact, <code>respx.mock</code> is an actual instance of <code>MockTransport</code>.</p>"},{"location":"versions/0.14.0/mocking/#mocktransport","title":"MockTransport","text":"<pre><code>import httpx\nimport respx\n\n\nmock_transport = respx.MockTransport()\nrequest = mock_transport.get(\"https://foo.bar/\", content=\"foobar\")\n\nwith mock_transport:\n    response = httpx.get(\"https://foo.bar/\")\n    assert request.called\n    assert response.status_code == 200\n    assert response.text == \"foobar\"\n</code></pre>"},{"location":"versions/0.14.0/mocking/#syncmocktransport","title":"SyncMockTransport","text":"<p>If you don't need to patch the original <code>HTTPX</code>/<code>HTTP Core</code> transports, then use the <code>SyncMockTransport</code> or <code>AsyncMockTransport</code> directly, by passing the <code>transport</code> arg when instantiating your <code>HTTPX</code> client, or alike.</p> <pre><code>import httpx\nimport respx\n\n\nmock_transport = respx.SyncMockTransport()\nrequest = mock_transport.get(\"https://foo.bar/\", content=\"foobar\")\n\nwith httpx.Client(transport=mock_transport) as client:\n    response = client.get(\"https://foo.bar/\")\n    assert request.called\n    assert response.status_code == 200\n    assert response.text == \"foobar\"\n</code></pre>"},{"location":"versions/0.14.0/mocking/#asyncmocktransport","title":"AsyncMockTransport","text":"<pre><code>import httpx\nimport respx\n\n\nmock_transport = respx.AsyncMockTransport()\nrequest = mock_transport.get(\"https://foo.bar/\", content=\"foobar\")\n\nasync with httpx.AsyncClient(transport=mock_transport) as client:\n    response = await client.get(\"https://foo.bar/\")\n    assert request.called\n    assert response.status_code == 200\n    assert response.text == \"foobar\"\n</code></pre> <p>NOTE</p> <p>The mock transports takes the same configuration arguments as the decorator / context manager.</p>"},{"location":"versions/0.14.0/mocking/#global-setup-teardown","title":"Global Setup &amp; Teardown","text":""},{"location":"versions/0.14.0/mocking/#pytest","title":"pytest","text":"<pre><code># conftest.py\nimport pytest\nimport respx\n\n\n@pytest.fixture\ndef mocked_api():\n    with respx.mock(base_url=\"https://foo.bar\") as respx_mock:\n        respx_mock.get(\"/users/\", content=[], alias=\"list_users\")\n        ...\n        yield respx_mock\n</code></pre> <pre><code># test_api.py\nimport httpx\n\n\ndef test_list_users(mocked_api):\n    response = httpx.get(\"https://foo.bar/users/\")\n    request = mocked_api[\"list_users\"]\n    assert request.called\n    assert response.json() == []\n</code></pre> <p>Tip</p> <p>Use a session scoped fixture <code>@pytest.fixture(scope=\"session\")</code> when your fixture contains multiple endpoints that not necessary gets called by a single test case, or disable the built-in <code>assert_all_called</code> check.</p>"},{"location":"versions/0.14.0/mocking/#unittest","title":"unittest","text":"<pre><code># testcases.py\n\nclass MockedAPIMixin:\n    def setUp(self):\n        self.mocked_api = respx.mock(base_url=\"https://foo.bar\")\n        self.mocked_api.get(\"/users/\", content=[], alias=\"list_users\")\n        ...\n        self.mocked_api.start()\n\n    def tearDown(self):\n        self.mocked_api.stop()\n</code></pre> <pre><code># test_api.py\n\nimport unittest\nimport httpx\n\nfrom .testcases import MockedAPIMixin\n\n\nclass MyTestCase(MockedAPIMixin, unittest.TestCase):\n    def test_list_users(self):\n        response = httpx.get(\"https://foo.bar/users/\")\n        request = self.mocked_api[\"list_users\"]\n        assert request.called\n        assert response.json() == []\n</code></pre> <p>Tip</p> <p>Use <code>setUpClass</code> and <code>tearDownClass</code> when you mock multiple endpoints that not  necessary gets called by a single test method, or disable the built-in <code>assert_all_called</code> check.</p>"},{"location":"versions/0.14.0/mocking/#async-support","title":"Async Support","text":"<p>You can use <code>respx.mock</code> in both sync and async contexts to mock out <code>HTTPX</code> responses.</p>"},{"location":"versions/0.14.0/mocking/#pytest_1","title":"pytest","text":"<pre><code>@respx.mock\n@pytest.mark.asyncio\nasync def test_something():\n    async with httpx.AsyncClient() as client:\n        request = respx.get(\"https://foo.bar/\", content=\"foobar\")\n        response = await client.get(\"https://foo.bar/\")\n        assert request.called\n        assert response.text == \"foobar\"\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_something():\n    async with respx.mock:\n        async with httpx.AsyncClient() as client:\n            request = respx.get(\"https://foo.bar/\", content=\"foobar\")\n            response = await client.get(\"https://foo.bar/\")\n            assert request.called\n            assert response.text == \"foobar\"\n</code></pre> <p>Session Scoped Fixtures</p> <p>If a session scoped RESPX fixture is used in an async context, you also need to broaden the <code>pytest-asyncio</code> event_loop fixture.  You can use the <code>session_event_loop</code> utility for this. </p> <pre><code># conftest.py\n\nimport pytest\nimport respx\nfrom respx.fixtures import session_event_loop as event_loop  # noqa: F401\n\n\n@pytest.fixture(scope=\"session\")\nasync def mocked_api(event_loop):  # noqa: F811\n    async with respx.mock(base_url=\"https://foo.bar\") as respx_mock:\n        ...\n        yield respx_mock\n</code></pre>"},{"location":"versions/0.14.0/mocking/#unittest_1","title":"unittest","text":"<pre><code>import asynctest\n\n\nclass MyTestCase(asynctest.TestCase):\n    @respx.mock\n    async def test_something(self):\n        async with httpx.AsyncClient() as client:\n            request = respx.get(\"https://foo.bar/\", content=\"foobar\")\n            response = await client.get(\"https://foo.bar/\")\n            assert request.called\n            assert response.text == \"foobar\"\n\n    async def test_something(self):\n        async with respx.mock:\n            async with httpx.AsyncClient() as client:\n                request = respx.get(\"https://foo.bar/\", content=\"foobar\")\n                response = await client.get(\"https://foo.bar/\")\n                assert request.called\n                assert response.text == \"foobar\"\n</code></pre>"}]}